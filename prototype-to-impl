using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Castle.Core;
using Castle.Core.Internal;
using Castle.DynamicProxy;
using Castle.MicroKernel;
using Castle.MicroKernel.ComponentActivator;
using Castle.MicroKernel.Context;
using Castle.MicroKernel.Registration;
using Castle.Windsor;

namespace AllowNull
{
    public class Program
    {
        public static void Main(string[] args)
        {
            IWindsorContainer container = new WindsorContainer();
            container.Register(Component.For<IFoo>()
                .UsingFactoryMethodAllowNull(Foo.CreateFoo));
            container.Register(Component
                .For<IBar>().ImplementedBy<Bar>());

            var service = container.Resolve<IBar>();
            service.PeekABoo();
        }
    }

    public static class CRE
    {
        public static ComponentRegistration<TService> UsingFactoryMethodAllowNull<TImpl, TService>(this ComponentRegistration<TService> self, Func<TImpl> factoryMethod,
            bool managedExternally = false)
            where TImpl : TService where TService : class
        {
            return self.UsingFactoryMethodAllowNull((k, m, c) => factoryMethod(), managedExternally);
        }
        public static ComponentRegistration<TService> UsingFactoryMethodAllowNull<TImpl, TService>(this ComponentRegistration<TService> self,
            Func<IKernel, TImpl> factoryMethod,
            bool managedExternally = false)
            where TImpl : TService where TService : class
        {
            return self.UsingFactoryMethodAllowNull((k, m, c) => factoryMethod(k), managedExternally);
        }

        public static ComponentRegistration<TService> UsingFactoryMethodAllowNull<TService, TImpl>(
            this ComponentRegistration<TService> self,
            Func<IKernel, ComponentModel, CreationContext, TImpl> factoryMethod,
            bool managedExternally = false)
            where TImpl : TService where TService : class
        {
            self.Activator<FactoryMethodActivatorAllowingNull<TImpl>>()
                .ExtendedProperties(Property.ForKey("factoryMethodDelegate").Eq(factoryMethod));
            if (managedExternally)
            {
                self.ExtendedProperties(Property.ForKey("factory.managedExternally").Eq(managedExternally));
            }

            //Note: Hack, I would sugest providing a public property for this list which returned the list, as readonly unless there could be some value in changes to it.
            List<Type> potentialServices = (List<Type>)self.GetType()
                .GetField("potentialServices", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(self);
            var firstService = potentialServices.First().GetTypeInfo();

            //var firstService = self.Services.First().GetTypeInfo();
            if (self.Implementation == null &&
                (firstService.IsClass == false || firstService.IsSealed == false))
            {
                self.ImplementedBy(typeof(LateBoundComponent));
            }
            return self;
        }
    }


    public class FactoryMethodActivatorAllowingNull<T> : DefaultComponentActivator, IDependencyAwareActivator
    {
        protected readonly Func<IKernel, ComponentModel, CreationContext, T> creator;
        protected readonly bool managedExternally;

        public FactoryMethodActivatorAllowingNull(ComponentModel model, IKernelInternal kernel, ComponentInstanceDelegate onCreation, ComponentInstanceDelegate onDestruction)
            : base(model, kernel, onCreation, onDestruction)
        {
            creator = Model.ExtendedProperties["factoryMethodDelegate"] as Func<IKernel, ComponentModel, CreationContext, T>;
            managedExternally = (Model.ExtendedProperties["factory.managedExternally"] as bool?).GetValueOrDefault();
            if (creator == null)
            {
                throw new ComponentActivatorException(
                    $"{GetType().Name} received misconfigured component model for {Model.Name}. Are you sure you registered this component with \'UsingFactoryMethod\'?", Model);
            }
        }

        public bool CanProvideRequiredDependencies(ComponentModel component)
        {
            // the factory will take care of providing all dependencies.
            return true;
        }

        public bool IsManagedExternally(ComponentModel component)
        {
            return managedExternally;
        }

        protected override void ApplyCommissionConcerns(object instance)
        {
            if (managedExternally || instance == null)
            {
                return;
            }
            base.ApplyCommissionConcerns(instance);
        }

        protected override void ApplyDecommissionConcerns(object instance)
        {
            if (managedExternally || instance == null)
            {
                return;
            }
            base.ApplyDecommissionConcerns(instance);
        }

        public override object Create(CreationContext context, Burden burden)
        {
            var instance = InternalCreate(context);
            if (instance != null)
                burden.SetRootInstance(instance);
            OnCreation?.Invoke(Model, instance);
            return instance;
        }

        protected override object Instantiate(CreationContext context)
        {
            object instance = creator(Kernel, Model, context);
            if (ShouldCreateProxy(instance))
            {
                instance = Kernel.ProxyFactory.Create(Kernel, instance, Model, context);
            }
            return instance;
        }

        protected override void SetUpProperties(object instance, CreationContext context)
        {
            // we don't
        }

        private bool ShouldCreateProxy(object instance)
        {
            if (instance == null)
            {
                return false;
            }
            if (Kernel.ProxyFactory.ShouldCreateProxy(Model) == false)
            {
                return false;
            }
            return ProxyUtil.IsProxy(instance) == false;
        }
    }

    public interface IFoo { }
    public class Foo : IFoo
    {
        public static IFoo CreateFoo() => null;
    }

    public interface IBar
    {
        void PeekABoo();
    }

    public class Bar : IBar
    {
        private readonly IFoo foo;
        public Bar(IFoo foo = null) => this.foo = foo;
        public void PeekABoo() => Console.WriteLine("My foo was " + (foo?.ToString() ?? "NULL"));
    }
}
